{
    "componentChunkName": "component---src-templates-prose-tsx",
    "path": "/machine-learning/let-us-play-with-emotions",
    "result": {"data":{"post":{"slug":"/machine-learning/let-us-play-with-emotions","title":"Let us play with emotions","description":"Fine-tuning BERT tutorial with PyTorch for emotion classification.","excerpt":"In today’s tutorial, we will play with emotions, quite literally! With the growing trends in machine learning and importance to emulate…","body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Let us play with emotions\",\n  \"subtitle\": \"\",\n  \"date\": \"2021-03-25T00:00:00.000Z\",\n  \"lastUpdated\": \"2021-03-25T00:00:00.000Z\",\n  \"description\": \"Fine-tuning BERT tutorial with PyTorch for emotion classification.\",\n  \"type\": \"prose\",\n  \"category\": \"Machine Learning\",\n  \"image\": \"/og-images/theme-ui-plugin.png?v=1\",\n  \"published\": true\n};\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\nvar Alert = makeShortcode(\"Alert\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In today\\u2019s tutorial, we will play with emotions, quite literally! With the growing trends in machine learning and importance to emulate human character/ traits by machines, it is vital that we understand the importance of emotion in our day to day life. In today\\u2019s world, emotional context can be applied to every aspect of our life, be it a morning meme you scroll through to , or the serenity in music, or a kid describing his first day at the guitar class!\"), mdx(Alert, {\n    status: \"info\",\n    title: \"Thought to ponder\",\n    mdxType: \"Alert\"\n  }, mdx(\"p\", null, \"The point I would like to make here is : Information when analysed for emotion, can often reveal surprising traits!\")), mdx(\"p\", null, \"Recommender systems use this underlying trait to provide best class and relevant suggestions. From Amazon to Youtube, the product recommendations to the next autoplay video, emotions are consumed in every step! Hard to believe? Go try it yourself !\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1024px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/0c9c0898372223d8185af260b3f2f930/12e67/emotions.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.796875%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAABA//EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHqo2Sqjyf/xAAZEAEBAAMBAAAAAAAAAAAAAAABAAIDEiH/2gAIAQEAAQUCydjGXnZOLcs6xv/EABYRAAMAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPwGBf//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/Aaf/xAAZEAACAwEAAAAAAAAAAAAAAAAAIQIQMRH/2gAIAQEABj8CUuK9NGf/xAAdEAACAgEFAAAAAAAAAAAAAAAAASFBURExYXGh/9oACAEBAAE/IamhehNyrGh7mAngXtrJ06D/2gAMAwEAAgADAAAAEOjf/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAwEBPxATuyF//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERQf/aAAgBAgEBPxCphWf/xAAbEAEAAwEBAQEAAAAAAAAAAAABABEhMVFBgf/aAAgBAQABPxBW2sYB25riQKOsriIqwKxdeW/YtRyn07+ogOkArMJ//9k=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"fake news\",\n    \"title\": \"fake news\",\n    \"src\": \"/static/0c9c0898372223d8185af260b3f2f930/87945/emotions.jpg\",\n    \"srcSet\": [\"/static/0c9c0898372223d8185af260b3f2f930/b95e4/emotions.jpg 256w\", \"/static/0c9c0898372223d8185af260b3f2f930/1779b/emotions.jpg 512w\", \"/static/0c9c0898372223d8185af260b3f2f930/87945/emotions.jpg 1024w\", \"/static/0c9c0898372223d8185af260b3f2f930/6afe2/emotions.jpg 1536w\", \"/static/0c9c0898372223d8185af260b3f2f930/7a411/emotions.jpg 2048w\", \"/static/0c9c0898372223d8185af260b3f2f930/12e67/emotions.jpg 4847w\"],\n    \"sizes\": \"(max-width: 1024px) 100vw, 1024px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\nsource: unsplash.com\"), mdx(\"h2\", {\n    \"id\": \"problem-at-hand\"\n  }, \"Problem at Hand\"), mdx(\"p\", null, \"Before we dive into emotional classification, let us understand sentiment analysis and how emotions are linked to it. Sentiment analysis is an effective method to portray sentiment polarity. Consider a movie review or a product review, sentiment analysis is used to capture public sentiment in reaction to a particular brand, which in turn influences future business decisions. If you like a movie, or favor a product, you will talk positively about it. This inturn will drive sales or increase viewership in case of a movie. However, a definite flaw in this method is that we can categorize a text either into positive/negative class, when there are so many possible emotions attached to it. A positive or a negative review does not justify the emotions attached to it. A movie you liked or you loved will still be categorized as a positive sentiment. However, it misses the intensity of liking towards the movie. The answer to this problem is Emotion Classification and today we are going to drill on that a bit. So with a cheerful face, let\\u2019s begin!\"), mdx(\"h2\", {\n    \"id\": \"the-emotional-data\"\n  }, \"The Emotional data\"), mdx(\"p\", null, \"Consider a sentence :\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" \", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"\\u2018I wish I could go to play today\\u2019\"), \" \"), \". Now if someone asks you what is the emotion exhibited here, I am sure you would say :sadness:. However, on looking closely, you will notice that the sentence has no negative word that can help the model classify it as a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" \\u201Csad\\u201D \"), \" sentence. This is the first challenge we face in emotion classification! Adding to this, it is tricky to teach machines sarcasm,irony and indirect meanings!\"), mdx(\"p\", null, \"Today we will deal with a document dataset created by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://huggingface.co/\"\n  }, \"the hugging team \"), \". Dataset has three files, split into training, test and validation sets. An example of the data is as below :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"i feel like I am still looking at a blank canvas blank pieces of paper;sadness`\\n\")), mdx(\"p\", null, \"The dataset has \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" 20000 \"), \" rows with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" 6 \"), \" different possible classes namely: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" Anger, Fear, Joy, Love, Sadness, Surprise. \")), mdx(\"h2\", {\n    \"id\": \"approach-to-emotional-classification\"\n  }, \"Approach to Emotional Classification\"), mdx(\"p\", null, \"We can build good sentiment classifiers even with only reasonably modest-size label training sets. Plethora of pre-trained word embeddings are readily available such as Word2Vec, GloVe, Fasttext, ConceptNet NumberBatch, etc. However, these embeddings are non-polysemic in nature, translating to only one representation of a word despite its occurrence in different contexts. Considering this shortcoming, in this scope, we will explore embeddings from Google\\u2019s BERT model.\"), mdx(\"h2\", {\n    \"id\": \"what-is-the-bert-model\"\n  }, \"What is the BERT model?\"), mdx(\"p\", null, \"BERT stands for Bidirectional Encoder Representations from Transformers and is a NLP model developed by Google for pre-training language representations. It leverages an enormous amount of plain text data publicly available (Wikipedia and Google Books) on the web and is trained in an unsupervised manner. It is a powerful model that is trained to learn the language structure and it\\u2019s nuances by training a Language Model. BERT has a deep bi-directional structure to it unlike ELMo, which is a shallow bi-directional and OpenAI GPT which is uni-directional in nature. Bidirectional nature helps the model to capture the context from previous words and words ahead of it any given time . I would recommend \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://jalammar.github.io/illustrated-bert/\"\n  }, \"reading this\"), \" in order to understand functionality of BERT even better.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"But first, setup: \"))), mdx(\"h4\", {\n    \"id\": \"exploiting-google-colab-gpu\"\n  }, \"Exploiting Google Colab GPU\"), mdx(\"p\", null, \"Google Colab offers free GPUs and TPUs! BERT models consume huge memory and to aid it, it is advisable to take advantage of GPU.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\nnum_gpu = torch.cuda.device_count()\\ntorch.cuda.get_device_name(0)\\nSEED = 9\\nrandom.seed(SEED)\\nnp.random.seed(SEED)\\ntorch.manual_seed(SEED)\\nif device == torch.device(\\\"cuda\\\"):\\n    torch.cuda.manual_seed_all(SEED)\\n\")), mdx(Alert, {\n    status: \"info\",\n    title: \"Note!\",\n    mdxType: \"Alert\"\n  }, mdx(\"p\", null, \"For torch to use the GPU, we need to identify and specify the GPU as the device. This will mainly come into picture when we train the model. Ayt that time, we will load the data onto the device.\")), mdx(\"p\", null, \"Next, let\\u2019s install the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/huggingface/transformers\"\n  }, \"transformers\"), \" package from Hugging Face which will give us a pytorch interface for working with BERT.At the moment, the Hugging Face library seems to be the most widely accepted and powerful pytorch interface for working with BERT. In addition to supporting a variety of different pre-trained transformer models, the library also includes pre-built modifications of these models suited to your specific task. For example, in this tutorial we will use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"BertForSequenceClassification\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"!pip install transformers\\n\")), mdx(\"h2\", {\n    \"id\": \"preprocessing-the-data\"\n  }, \"Preprocessing the Data\"), mdx(\"p\", null, \"Once we download and parse our data, it is time to encode our labels set. BEfore we encode our classes, we need to merge the three files to have the same label encoding.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"df = pd.concat([df_train,df_test,df_val])\\n\")), mdx(\"p\", null, \"We will use the LabelEncoder from sckit package.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"labelencoder = LabelEncoder()\\ndf['label_enc'] = labelencoder.fit_transform(df['label'])\\n\")), mdx(\"p\", null, \"Let\\u2019s extract the sentences and labels of our training set as numpy ndarrays.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"text={ `sentences = df.sentance.values\\nlabels = df.label.values\\n\")), mdx(\"h2\", {\n    \"id\": \"tokenization-and-attention-masks\"\n  }, \"Tokenization and Attention Masks\"), mdx(\"p\", null, \"BERT models take in a specific format. In order to do so, we need to transform our data into tokens.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1024px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/b2ac1d2c98f61e544f9243a6cab29bb7/d100f/token.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"31.25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdiEAf/EABYQAQEBAAAAAAAAAAAAAAAAAAARMf/aAAgBAQABBQLUR//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABcQAAMBAAAAAAAAAAAAAAAAAAABgSH/2gAIAQEAAT8heEyCD//aAAwDAQACAAMAAAAQi+//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQMBAT8Qq6//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8QiY//xAAbEAEAAgIDAAAAAAAAAAAAAAABAEFx0RGR8f/aAAgBAQABPxAoTV5zOfh3F09Hc//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Bert model picture\",\n    \"title\": \"Bert model picture\",\n    \"src\": \"/static/b2ac1d2c98f61e544f9243a6cab29bb7/87945/token.jpg\",\n    \"srcSet\": [\"/static/b2ac1d2c98f61e544f9243a6cab29bb7/b95e4/token.jpg 256w\", \"/static/b2ac1d2c98f61e544f9243a6cab29bb7/1779b/token.jpg 512w\", \"/static/b2ac1d2c98f61e544f9243a6cab29bb7/87945/token.jpg 1024w\", \"/static/b2ac1d2c98f61e544f9243a6cab29bb7/d100f/token.jpg 1174w\"],\n    \"sizes\": \"(max-width: 1024px) 100vw, 1024px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\nSource: BERT \", \"[Devlin et al., 2018]\", \", with modifications\"), mdx(\"p\", null, \"The input text to BERT must be split into tokens, further on these tokens must be mapped to their index in the tokenizer vocabulary. Tokenization is performed using the tokenizer provided with BERT.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"MAX_LEN = 256\\ntokenizer = BertTokenizer.from_pretrained('bert-base-uncased',do_lower_case=True)\\ninput_ids = [tokenizer.encode(sent, add_special_tokens=True,max_length=MAX_LEN,pad_to_max_length=True) for sent in sentences]\\nlabels = df.label.values\\n\")), mdx(\"p\", null, \"As you must have noticed, we had \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"add_special_tokens=True\"), \" \")), mdx(\"p\", null, \"At the end of every sentence, we need to append the special \", \"[SEP]\", \" token and prepend the special \", \"[CLS]\", \" token to the beginning of every sentence.\"), mdx(\"p\", null, \"[SEP]\", \" is used mainly to separate two sentences and describe something among them. Eg: Is A and B related to one another .\\n\", \"[CLS]\", \" has special importance in the classification task.\\nThe final hidden state corresponding to this token is used as the aggregate sequence representation for classification tasks.\\u201D\"), mdx(\"p\", null, \"Next important parameter is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"max_length\")), \" .\"), mdx(\"p\", null, \"Did you notice how each input sentence has a varying length. In order to handle this variation, we can either append, or truncate to a single, fixed length. The maximum sentence length, BERT can handle is 512 tokens. In our case, we will restrict the max length to 256 tokens. For a sentence smaller than 256 tokens, the remaining space is padded with \", \"[PAD]\", \" token with index 0 in BERT vocabulary.\"), mdx(\"p\", null, \"Now that we have tokenized and added special tokens, we need to let BERT know where to pay attention. This is done via an attention mask. The \\u201CAttention Mask\\u201D is simply an array of 1s and 0s indicating which tokens are padding and which aren\\u2019t. Further reading can be done \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://huggingface.co/transformers/\"\n  }, \"here\"), \" to get a better understanding of this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"## Create attention mask\\nattention_masks = []\\n## Create a mask of 1 for all input tokens and 0 for all padding tokens\\nattention_masks = [[float(i>0) for i in seq] for seq in input_ids]\\n\")), mdx(\"h2\", {\n    \"id\": \"train-and-validation-split\"\n  }, \"Train and Validation Split\"), mdx(\"p\", null, \"Divide up our training set to use 90% for training and 10% for validation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"train_inputs,validation_inputs,train_labels,validation_labels = train_test_split(input_ids,labels,random_state=41,test_size=0.1)\\ntrain_masks,validation_masks,_,_ = train_test_split(attention_masks,input_ids,random_state=41,test_size=0.1)\\n\")), mdx(\"h2\", {\n    \"id\": \"pytorch-data-types-and-data-loaders\"\n  }, \"Pytorch Data Types and Data loaders\"), mdx(\"p\", null, \"The numpy.ndarrays needs to be converted into pytorch tensors. Later on we need to wrap them in a data loader . This would help us save memory during training. We do need to iterate over the entire dataset and load in memory at once. Notice how we have two data loaders defined for training and validation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"# convert all our data into torch tensors, required data type for our model\\ntrain_inputs = torch.tensor(train_inputs)\\nvalidation_inputs = torch.tensor(validation_inputs)\\ntrain_labels = torch.tensor(train_labels)\\nvalidation_labels = torch.tensor(validation_labels)\\ntrain_masks = torch.tensor(train_masks)\\nvalidation_masks = torch.tensor(validation_masks)\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"batch_size = 32\\ntrain_data = TensorDataset(train_inputs,train_masks,train_labels)\\ntrain_sampler = RandomSampler(train_data)\\ntrain_dataloader = DataLoader(train_data,sampler=train_sampler,batch_size=batch_size)\\n## validation dataloader\\nvalidation_data = TensorDataset(validation_inputs,validation_masks,validation_labels)\\nvalidation_sampler = RandomSampler(validation_data)\\nvalidation_dataloader = DataLoader(validation_data,sampler=validation_sampler,batch_size=batch_size)\\n\")), mdx(\"h2\", {\n    \"id\": \"bert-for-sequence-classification\"\n  }, \"Bert For Sequence Classification\"), mdx(\"p\", null, \"Now that we have the right data format and our data loader is ready , it is time to train the model. We will use the classification model from BERT. .For classification, the normal BERT model is added with a single linear layer on top for classification.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"978px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/28642b36bc64f6b0966c08e63eeb711e/35924/linear.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"67.578125%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHahlLgD//EABkQAAIDAQAAAAAAAAAAAAAAAAIRAAEhEv/aAAgBAQABBQIm9cIXfOz/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAEBAQAAAAAAAAAAAAAAAAAxACD/2gAIAQEABj8CZz//xAAbEAABBAMAAAAAAAAAAAAAAAABABARQTFRgf/aAAgBAQABPyEMEERyNZI76b//2gAMAwEAAgADAAAAENvP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhAAAgMBAQAAAAAAAAAAAAAAATEAESEQQf/aAAgBAQABPxDaMFLYsqKel1wATYZAFiBc/9k=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"image of bert classification model\",\n    \"title\": \"image of bert classification model\",\n    \"src\": \"/static/28642b36bc64f6b0966c08e63eeb711e/35924/linear.jpg\",\n    \"srcSet\": [\"/static/28642b36bc64f6b0966c08e63eeb711e/b95e4/linear.jpg 256w\", \"/static/28642b36bc64f6b0966c08e63eeb711e/1779b/linear.jpg 512w\", \"/static/28642b36bc64f6b0966c08e63eeb711e/35924/linear.jpg 978w\"],\n    \"sizes\": \"(max-width: 978px) 100vw, 978px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\nsource: jalammar.github.io/illustrated-bert/\"), mdx(\"p\", null, \"We load the BERT \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"bert-base-uncased\")), \" . uncased refers to lowercase while base refers to the smaller version model .\\nIn transformers, optimizer and schedules are instantiated like this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"model = BertForSequenceClassification.from_pretrained(\\\"bert-base-uncased\\\", num_labels=6).to(device)\\n\")), mdx(\"h3\", {\n    \"id\": \"setting-up-hyperparamters\"\n  }, \"Setting up Hyperparamters\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Batch size: 32\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Learning rate : 2e-5\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Epochs : 2\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Epsilon : 1e-8 (to avoid small number division by zero)\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"optimizer = AdamW(model.parameters(), lr=lr,eps=adam_epsilon,correct_bias=False)  # To reproduce BertAdam specific behavior set correct_bias=False\\nscheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=num_warmup_steps, num_training_steps=num_training_steps)\\n\")), mdx(\"h2\", {\n    \"id\": \"let-the-training-begin\"\n  }, \"Let the Training Begin!\"), mdx(\"p\", null, \"For each pass, we have a training and a validation phase. Let us understand the core of each of these phases.\"), mdx(\"h4\", {\n    \"id\": \"training\"\n  }, \"Training:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Unpack the data and labels from the iterator\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Loading the data on the GPU (to.device)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Clearing the gradients from previous pass\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Forward pass through the model\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Backward pass\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Updating model parameters (optimizer.step())\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Save variables for each step/epoch monitoring\")), mdx(\"h4\", {\n    \"id\": \"validation\"\n  }, \"Validation:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Unpack the data and labels from the iterator\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Loading the data on the GPU (to.device)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Forward pass through the model\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Compute Loss on the validation data\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Save variables for each step/epoch monitoring\")), mdx(\"p\", null, \"Now that the training flow is understood, let us look at the code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"for _ in tnrange(1,epochs+1,desc='Epoch'):\\n  print(\\\"<\\\" + \\\"=\\\"*22 + F\\\" Epoch {_} \\\"+ \\\"=\\\"*22 + \\\">\\\")\\n  # Calculate total loss for this epoch\\n  batch_loss = 0\\n  for step, batch in enumerate(train_dataloader):\\n    # Set our model to training mode (as opposed to evaluation mode)\\n    model.train()\\n\\n    # Add batch to GPU\\n    batch = tuple(t.to(device) for t in batch)\\n\\n    # Unpack the inputs from our dataloader\\n    b_input_ids, b_input_mask, b_labels = batch\\n\\n    # Forward pass\\n    outputs = model(b_input_ids, token_type_ids=None, attention_mask=b_input_mask, labels=b_labels)\\n    loss = outputs[0]\\n\\n    # Backward pass\\n    loss.backward()\\n\\n    # Clip the norm of the gradients to 1.0\\n    # Gradient clipping is not in AdamW anymore\\n    torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\\n\\n    # Update parameters and take a step using the computed gradient\\n    optimizer.step()\\n\\n    # Update learning rate schedule\\n    scheduler.step()\\n\\n    # Clear the previous accumulated gradients\\n    optimizer.zero_grad()\\n\\n    # Update tracking variables\\n    batch_loss += loss.item()\\n  # Calculate the average loss over the training data.\\n  avg_train_loss = batch_loss / len(train_dataloader)\\n  #store the current learning rate\\n\\n  for param_group in optimizer.param_groups:\\n    print(\\\"\\\\n\\\\tCurrent Learning rate: \\\",param_group['lr'])\\n    learning_rate.append(param_group['lr'])\\n    train_loss_set.append(avg_train_loss)\\n  print(F'Average Training loss: {avg_train_loss}')\\n\\n  # Validation\\n\\n  # Put model in evaluation mode to evaluate loss on the validation set\\n  model.eval()\\n\\n  # Tracking variables\\n  eval_accuracy,eval_mcc_accuracy,nb_eval_steps = 0, 0, 0\\n  # Evaluate data for one epoch\\n  for batch in validation_dataloader:\\n    # Add batch to GPU\\n    batch = tuple(t.to(device) for t in batch)\\n    # Unpack the inputs from our dataloader\\n    b_input_ids, b_input_mask, b_labels = batch\\n    # Telling the model not to compute or store gradients, saving memory and speeding up validation\\n    with torch.no_grad():\\n      # Forward pass, calculate logit predictions\\n      logits = model(b_input_ids, token_type_ids=None, attention_mask=b_input_mask)\\n\\n    # Move logits and labels to CPU\\n    logits = logits[0].to('cpu').numpy()\\n    label_ids = b_labels.to('cpu').numpy()\\n\\n    pred_flat = np.argmax(logits, axis=1).flatten()\\n\\n    labels_flat = label_ids.flatten()\\n    df_metrics=pd.DataFrame({'Epoch':epochs,'Actual_class':labels_flat,'Predicted_class':pred_flat})\\n\\n    tmp_eval_accuracy = accuracy_score(labels_flat,pred_flat)\\n    tmp_eval_mcc_accuracy = matthews_corrcoef(labels_flat, pred_flat)\\n\\n    eval_accuracy += tmp_eval_accuracy\\n    eval_mcc_accuracy += tmp_eval_mcc_accuracy\\n\\n    nb_eval_steps += 1\\n\\n  print(F'Validation Accuracy: {eval_accuracy/nb_eval_steps}')\\n  print(F'Validation MCC Accuracy: {eval_mcc_accuracy/nb_eval_steps}')\\n\")), mdx(\"p\", null, \"Currently we have performed no hyperparameter tuning. Adjustments can be made in altering the learning rate, epochs, batch size, ADAM properties . I leave them for you to test and find the best set. Do let me know if you find some crazy differences. Note, how we did not train on the entire training dataset and kept aside a portion of it as our validation set for legibility of code. Another thing that impacts the overall performance is the random seed. Maybe, play with that too and notice the results. Finally, you can find the entire code on Github.\"));\n}\n;\nMDXContent.isMDXComponent = true;","seoLastUpdated":"2021-03-25T00:00:00.000Z","lastUpdated":"Mar 25, 2021","seoDate":"2021-03-25T00:00:00.000Z","yearDate":"2021","date":"Mar 25, 2021","subtitle":null,"timeToRead":6,"image":"/og-images/theme-ui-plugin.png?v=1","category":{"name":"Machine Learning","slug":"/machine-learning"},"parent":{"parent":{"relativePath":"2021-03-25-let's-play-with-emotions/index.mdx"}}}},"pageContext":{"slug":"/machine-learning/let-us-play-with-emotions"}},
    "staticQueryHashes": ["2299006781","3050858678","4184542181","712324210"]}